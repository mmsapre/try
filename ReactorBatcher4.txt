package com.example.ingest.batch;

import com.example.ingest.event.DbWriteEvent;
import com.example.ingest.event.DetailEventPublisher;
import com.example.ingest.model.ItemDetails;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.annotation.PostConstruct;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;
import reactor.core.publisher.Sinks;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Types;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Component
public class ReactorBatcher {

  private final JdbcTemplate jdbc;
  private final DetailEventPublisher pub;
  private final ObjectMapper om;

  private final Sinks.Many<ItemDetails> sink =
    Sinks.many().multicast().onBackpressureBuffer(50_000, false);

  private volatile UUID loadRowId;

  public ReactorBatcher(JdbcTemplate jdbc,
                        DetailEventPublisher pub,
                        ObjectMapper om) {
    this.jdbc = jdbc;
    this.pub = pub;
    this.om = om;
  }

  public void setLoadRowId(UUID id) { 
    this.loadRowId = id; 
  }

  @PostConstruct
  void init() {
    sink.asFlux()
      .bufferTimeout(500, Duration.ofSeconds(2))
      .flatMap(this::writeAndPublish)
      .subscribe();
  }

  public void accept(ItemDetails d) {
    sink.tryEmitNext(d);
  }

  private Mono<Void> writeAndPublish(List<ItemDetails> batch) {
  return Mono.fromCallable(() -> {

    List<DbWriteEvent> ev = new ArrayList<>();

    jdbc.execute((org.springframework.jdbc.core.ConnectionCallback<Void>) con -> {

      PreparedStatement ps = con.prepareStatement("""
        INSERT INTO api_item_data(load_rowid, ext_id, payload)
        VALUES (?, ?, ?::jsonb)
        ON CONFLICT (ext_id) DO NOTHING
        RETURNING row_id, ext_id
      """);

      for (ItemDetails d : batch) {
        ps.setObject(1, loadRowId);
        ps.setString(2, d.id());
        ps.setObject(3, om.writeValueAsString(d.payload()), Types.OTHER);

        ResultSet rs = ps.executeQuery();
        while (rs.next()) {
          ev.add(new DbWriteEvent(
              loadRowId,
              rs.getLong(1),
              rs.getString(2)
          ));
        }
      }
      return null;
    });

    ev.forEach(pub::publish);
    return null;
  });
}

}
