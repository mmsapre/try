@Component
public class ReactorBatcher {

  private final JdbcTemplate jdbc;
  private final DetailEventPublisher pub;
  private final ObjectMapper om;
  private final Sinks.Many<ItemDetails> sink =
    Sinks.many().multicast().onBackpressureBuffer(50000,false);
  private volatile UUID loadRowId;

  public void setLoadRowId(UUID id){ this.loadRowId=id; }

  @PostConstruct
  void init(){
    sink.asFlux().bufferTimeout(500,Duration.ofSeconds(2))
      .flatMap(this::writeAndPublish).subscribe();
  }

  public void accept(ItemDetails d){ sink.tryEmitNext(d); }

  private Mono<Void> writeAndPublish(List<ItemDetails> batch){
    return Mono.fromCallable(() -> {
      List<DbWriteEvent> ev = new ArrayList<>();
      jdbc.execute(con -> {
        PreparedStatement ps = con.prepareStatement("""
          INSERT INTO api_item_data(load_rowid,ext_id,payload)
          VALUES (?,?,?::jsonb)
          ON CONFLICT (ext_id) DO NOTHING
          RETURNING row_id,ext_id
        """);
        for(ItemDetails d:batch){
          ps.setObject(1,loadRowId);
          ps.setString(2,d.id());
          ps.setObject(3,om.writeValueAsString(d.payload()),Types.OTHER);
          ResultSet rs = ps.executeQuery();
          while(rs.next())
            ev.add(new DbWriteEvent(loadRowId,rs.getLong(1),rs.getString(2)));
        }
        return null;
      });
      ev.forEach(pub::publish);
      return null;
    });
  }
}
