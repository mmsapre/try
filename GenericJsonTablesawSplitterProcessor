
import org.json.JSONArray;
import org.json.JSONObject;
import tech.tablesaw.api.Table;
import tech.tablesaw.io.json.JsonReadOptions;

import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;

public class GenericJsonTablesawSplitterProcessor implements RecordProcessor<String, String> {

    private final boolean flattenNestedArrays;
    private final int maxDepth;
    private final List<Record<String>> results = new ArrayList<>();

    public GenericJsonTablesawSplitterProcessor(boolean flattenNestedArrays, int maxDepth) {
        this.flattenNestedArrays = flattenNestedArrays;
        this.maxDepth = maxDepth;
    }

    @Override
    public List<Record<String>> processRecord(Record<String> record) throws Exception {
        results.clear();
        String json = record.getPayload().trim();

        if (json.startsWith("[")) {
            recurseArray(new JSONArray(json), new JSONObject(), "root", 0);
        } else {
            recurseObject(new JSONObject(json), new JSONObject(), "root", 0);
        }

        return results;
    }

    private void recurseObject(JSONObject obj, JSONObject parentMeta, String path, int depth) {
        if (depth > maxDepth) return;

        JSONObject currentMeta = new JSONObject(parentMeta.toString());
        JSONObject flatData = new JSONObject();

        // Copy primitive fields first
        for (String key : obj.keySet()) {
            Object value = obj.get(key);
            if (value instanceof JSONArray array) {
                if (flattenNestedArrays && depth < maxDepth) {
                    // Handle flattening
                    for (int i = 0; i < array.length(); i++) {
                        Object item = array.get(i);
                        if (item instanceof JSONObject nestedObj) {
                            JSONObject merged = new JSONObject(currentMeta.toString());
                            for (String primitiveKey : obj.keySet()) {
                                if (!(obj.get(primitiveKey) instanceof JSONArray)) {
                                    merged.put(primitiveKey, obj.get(primitiveKey));
                                }
                            }
                            for (String field : nestedObj.keySet()) {
                                merged.put(field, nestedObj.get(field));
                            }
                            results.add(new GenericRecord<>(System.nanoTime(), merged.toString()));
                        } else {
                            JSONObject row = new JSONObject(currentMeta.toString());
                            row.put(key, item.toString());
                            results.add(new GenericRecord<>(System.nanoTime(), row.toString()));
                        }
                    }
                    return; // flattened, don't proceed deeper
                } else {
                    flatData.put(key, array.toString());
                }
            } else if (value instanceof JSONObject nested) {
                recurseObject(nested, currentMeta, path + "." + key, depth + 1);
                return;
            } else {
                flatData.put(key, value);
            }
        }

        // Merge flatData + parentMeta
        JSONObject output = new JSONObject(currentMeta.toString());
        for (String key : flatData.keySet()) {
            output.put(key, flatData.get(key));
        }

        results.add(new GenericRecord<>(System.nanoTime(), output.toString()));
    }

    private void recurseArray(JSONArray array, JSONObject parentMeta, String path, int depth) {
        if (depth > maxDepth) return;

        Table table = tryBuildTable(array);
        if (table != null) {
            for (int i = 0; i < table.rowCount(); i++) {
                JSONObject row = new JSONObject(parentMeta.toString());
                for (String col : table.columnNames()) {
                    row.put(col, table.column(col).getString(i));
                }
                results.add(new GenericRecord<>(System.nanoTime(), row.toString()));
            }
        } else {
            for (int i = 0; i < array.length(); i++) {
                Object item = array.get(i);
                if (item instanceof JSONObject obj) {
                    recurseObject(obj, parentMeta, path, depth + 1);
                } else {
                    JSONObject row = new JSONObject(parentMeta.toString());
                    row.put("value", item.toString());
                    results.add(new GenericRecord<>(System.nanoTime(), row.toString()));
                }
            }
        }
    }

    private Table tryBuildTable(JSONArray array) {
        try {
            return Table.read().usingOptions(JsonReadOptions.builder(new StringReader(array.toString())).build());
        } catch (Exception e) {
            return null;
        }
    }
}
