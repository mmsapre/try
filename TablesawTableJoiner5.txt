import tech.tablesaw.api.*;

import java.util.*;

public class TablesawTableJoiner {

    /**
     * FULL DENORMALIZATION:
     * - 1-1 joins â†’ merge columns
     * - 1-N joins â†’ explode rows
     */
    public static Table joinAllIntoOneTable(
            Map<String, Table> flatTables,
            Map<String, List<JoinSpec>> joinSpecs,
            String rootTableKey
    ) {

        if (!flatTables.containsKey(rootTableKey)) {
            throw new IllegalArgumentException("Root table not found: " + rootTableKey);
        }

        // Start from root
        Table result = cleanup(flatTables.get(rootTableKey));

        // Apply joins breadth-first
        for (Map.Entry<String, List<JoinSpec>> entry : joinSpecs.entrySet()) {

            String childKey = entry.getKey();
            if (!flatTables.containsKey(childKey)) continue;

            Table child = cleanup(flatTables.get(childKey));

            for (JoinSpec spec : entry.getValue()) {

                if (!flatTables.containsKey(spec.joinWith)) continue;

                // Only join if current result contains the parent key
                if (!result.columnNames().contains(spec.rightKey)) continue;

                // Drop duplicate columns (except FK)
                Set<String> resultCols = new HashSet<>(result.columnNames());
                List<String> drop = new ArrayList<>();

                for (String c : child.columnNames()) {
                    if (!c.equals(spec.leftKey) && resultCols.contains(c)) {
                        drop.add(c);
                    }
                }

                if (!drop.isEmpty()) {
                    child = child.removeColumns(drop.toArray(new String[0]));
                }

                // ðŸš€ THIS IS THE KEY LINE (1-1 and 1-N both explode correctly)
                result = result
                        .joinOn(spec.rightKey)
                        .leftOuter(child, spec.leftKey);
            }
        }

        return result;
    }

    private static Table cleanup(Table t) {
        if (t.columnNames().contains("sourcePath")) {
            t = t.removeColumns("sourcePath");
        }
        return t.copy();
    }

public static Table unionByNameDedupRowId(
        Table base,
        Table incoming,
        String rowIdColumn
) {

    Table aligned = incoming.copy();

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 1. SNAPSHOT schemas (avoid live view issues)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Set<String> baseCols = new LinkedHashSet<>(base.columnNames());
    Set<String> alignedCols = new LinkedHashSet<>(aligned.columnNames());

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 2. Add missing columns
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    for (Column<?> c : base.columns()) {
        if (!alignedCols.contains(c.name())) {
            aligned.addColumns(c.emptyCopy(aligned.rowCount()));
        }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 3. Drop extra columns
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    for (String col : alignedCols) {
        if (!baseCols.contains(col)) {
            aligned.removeColumns(col);
        }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 4. Reorder columns
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    aligned = aligned.retainColumns(
        baseCols.toArray(new String[0])
    );

  if (rowIdColumn != null
                && base.columnNames().contains(rowIdColumn)
                && aligned.columnNames().contains(rowIdColumn)) {

            dropDuplicateRowIds(base, aligned, rowIdColumn);
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // 6. FINAL SAFETY CHECK
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (!base.structure().equals(aligned.structure())) {
            throw new IllegalStateException(
                    "Schema mismatch after unionByName\n" +
                    "Base: " + base.structure() + "\n" +
                    "Aligned: " + aligned.structure()
            );
        }


    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 7. CONCAT
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    return Table.concat(base, aligned);
}
 private static void dropDuplicateRowIds(
            Table base,
            Table aligned,
            String rowIdColumn
    ) {

        Column<?> baseRowId = base.column(rowIdColumn);
        Column<?> incomingRowId = aligned.column(rowIdColumn);

        Set<Object> existingIds = new HashSet<>(base.rowCount());

        for (int i = 0; i < base.rowCount(); i++) {
            existingIds.add(baseRowId.get(i));
        }

        Selection keep = Selection.with();

        for (int i = 0; i < aligned.rowCount(); i++) {
            Object val = incomingRowId.get(i);
            if (val == null || !existingIds.contains(val)) {
                keep.add(i);
            }
        }

        aligned.retainRows(keep);
    }

    /**
     * Decides append vs union automatically.
     */
    public static Table appendOrUnion(
            Table base,
            Table incoming,
            String rowIdColumn
    ) {
        if (base.structure().equals(incoming.structure())) {
            base.append(incoming);
            return base;
        }
        return unionByNameDedupRowId(base, incoming, rowIdColumn);
    }
}
