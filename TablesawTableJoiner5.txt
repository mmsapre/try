import tech.tablesaw.api.*;

import java.util.*;

public class TablesawTableJoiner {

    /**
     * FULL DENORMALIZATION:
     * - 1-1 joins â†’ merge columns
     * - 1-N joins â†’ explode rows
     */
    public static Table joinAllIntoOneTable(
            Map<String, Table> flatTables,
            Map<String, List<JoinSpec>> joinSpecs,
            String rootTableKey
    ) {

        if (!flatTables.containsKey(rootTableKey)) {
            throw new IllegalArgumentException("Root table not found: " + rootTableKey);
        }

        // Start from root
        Table result = cleanup(flatTables.get(rootTableKey));

        // Apply joins breadth-first
        for (Map.Entry<String, List<JoinSpec>> entry : joinSpecs.entrySet()) {

            String childKey = entry.getKey();
            if (!flatTables.containsKey(childKey)) continue;

            Table child = cleanup(flatTables.get(childKey));

            for (JoinSpec spec : entry.getValue()) {

                if (!flatTables.containsKey(spec.joinWith)) continue;

                // Only join if current result contains the parent key
                if (!result.columnNames().contains(spec.rightKey)) continue;

                // Drop duplicate columns (except FK)
                Set<String> resultCols = new HashSet<>(result.columnNames());
                List<String> drop = new ArrayList<>();

                for (String c : child.columnNames()) {
                    if (!c.equals(spec.leftKey) && resultCols.contains(c)) {
                        drop.add(c);
                    }
                }

                if (!drop.isEmpty()) {
                    child = child.removeColumns(drop.toArray(new String[0]));
                }

                // ðŸš€ THIS IS THE KEY LINE (1-1 and 1-N both explode correctly)
                result = result
                        .joinOn(spec.rightKey)
                        .leftOuter(child, spec.leftKey);
            }
        }

        return result;
    }

    private static Table cleanup(Table t) {
        if (t.columnNames().contains("sourcePath")) {
            t = t.removeColumns("sourcePath");
        }
        return t.copy();
    }
}
