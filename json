import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.bohnman.squiggly.Squiggly;
import com.github.bohnman.squiggly.context.provider.SimpleSquigglyContextProvider;
import com.github.bohnman.squiggly.parser.SquigglyParser;
import com.jayway.jsonpath.Configuration;
import com.jayway.jsonpath.JsonPath;
import com.jayway.jsonpath.Option;
import org.bson.Document;

import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

public class MongoJsonPathArrayFieldSerializer extends JsonSerializer<Document> {

    private final ObjectMapper objectMapper;
    private final String squigglyFilter;
    private final Set<String> arrayFields;
    private final Map<String, List<String>> jsonPathFilters;

    public MongoJsonPathArrayFieldSerializer(String fields, Map<String, List<String>> jsonPathFilters) {
        this.squigglyFilter = extractNonArrayFields(fields);
        this.arrayFields = extractArrayFields(fields);
        this.jsonPathFilters = jsonPathFilters;
        this.objectMapper = new ObjectMapper();

        // Correct Squiggly initialization
        Squiggly.init(objectMapper, new SimpleSquigglyContextProvider(new SquigglyParser(), squigglyFilter));
    }

    @Override
    public void serialize(Document document, JsonGenerator gen, SerializerProvider serializers) throws IOException {
        try {
            // Convert MongoDB Document to JSON string
            String json = objectMapper.writeValueAsString(document);

            // Apply Squiggly filtering (for non-array fields)
            String squigglyFilteredJson = objectMapper.writeValueAsString(objectMapper.readTree(json));

            // Apply JSONPath filtering only for array fields
            String finalFilteredJson = applyJsonPathArrayFiltering(squigglyFilteredJson, arrayFields, jsonPathFilters);

            // Write the final JSON
            gen.writeRawValue(finalFilteredJson);
        } catch (Exception e) {
            throw new IOException("Error in MongoDB custom serialization", e);
        }
    }

    /**
     * Extract fields that are **not arrays** (for Squiggly filtering).
     */
    private String extractNonArrayFields(String fields) {
        return Arrays.stream(fields.split(","))
                .filter(f -> !f.contains("[].")) // Exclude array fields
                .collect(Collectors.joining(","));
    }

    /**
     * Extract only the **array fields** (for JSONPath filtering).
     */
    private Set<String> extractArrayFields(String fields) {
        return Arrays.stream(fields.split(","))
                .filter(f -> f.contains("[].")) // Include only array fields
                .map(f -> f.replace("[].", ".")) // Convert to JSONPath format
                .collect(Collectors.toSet());
    }

    /**
     * Apply JSONPath filtering **only on array fields**.
     */
    private String applyJsonPathArrayFiltering(String json, Set<String> arrayFields, Map<String, List<String>> filters) throws Exception {
        Object document = Configuration.defaultConfiguration()
                .addOptions(Option.SUPPRESS_EXCEPTIONS) // Ignore missing fields
                .jsonProvider()
                .parse(json);

        for (String field : arrayFields) {
            // Convert field name into JSONPath syntax
            String jsonPath = field;

            if (filters.containsKey(jsonPath)) {
                List<String> expectedValues = filters.get(jsonPath);

                // Extract matching elements
                List<Object> matchingElements = JsonPath.read(document, "$." + jsonPath);

                if (matchingElements != null) {
                    Iterator<Object> iterator = matchingElements.iterator();
                    while (iterator.hasNext()) {
                        Object element = iterator.next();
                        if (!expectedValues.contains(element.toString())) {
                            iterator.remove();
                        }
                    }
                }
            }
        }

        return objectMapper.writeValueAsString(document);
    }
}
