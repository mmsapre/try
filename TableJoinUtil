import tech.tablesaw.api.*;

import java.util.*;

public class TableJoinUtil {

    public static Table joinAllParentIdLinkedTables(Map<String, Table> tables) {
        Map<String, Table> tableMap = new HashMap<>(tables);
        Map<String, Table> joinedMap = new HashMap<>();

        // Copy tables and remove sourcePath column
        for (Map.Entry<String, Table> entry : tableMap.entrySet()) {
            Table original = entry.getValue();
            if (original.columnNames().contains("sourcePath")) {
                original = original.removeColumns("sourcePath");
            }
            joinedMap.put(entry.getKey(), original.copy());
        }

        for (Map.Entry<String, Table> childEntry : joinedMap.entrySet()) {
            String childKey = childEntry.getKey();
            Table child = childEntry.getValue();
            if (!child.columnNames().contains("parent_id")) continue;

            // Find parent with _row_id matching child.parent_id
            String parentKey = findParentTableKey(childKey, child, joinedMap);
            if (parentKey == null) continue;

            Table parent = joinedMap.get(parentKey);
            if (parent == null || !parent.columnNames().contains("_row_id")) continue;

            // Drop overlapping columns from child (except parent_id)
            Set<String> parentCols = new HashSet<>(parent.columnNames());
            List<String> toDrop = new ArrayList<>();
            for (String col : child.columnNames()) {
                if (!col.equals("parent_id") && parentCols.contains(col)) {
                    toDrop.add(col);
                }
            }

            if (!toDrop.isEmpty()) {
                child = child.removeColumns(toDrop.toArray(new String[0]));
            }

            Table joined = parent.joinOn("_row_id").inner(child, "parent_id");
            joinedMap.put(childKey, joined);
        }

        return mergeAll(joinedMap.values());
    }


    public static Table joinAllBySpec(Map<String, Table> tables, Map<String, JoinSpec> joinSpecs) {
        Map<String, Table> working = new HashMap<>();

        // Clean tables and remove sourcePath
        for (Map.Entry<String, Table> entry : tables.entrySet()) {
            Table t = entry.getValue();
            if (t.columnNames().contains("sourcePath")) {
                t = t.removeColumns("sourcePath");
            }
            working.put(entry.getKey(), t.copy());
        }

        List<Table> joinedResults = new ArrayList<>();

        for (Map.Entry<String, JoinSpec> entry : joinSpecs.entrySet()) {
            String childKey = entry.getKey();
            JoinSpec spec = entry.getValue();

            if (!working.containsKey(childKey) || !working.containsKey(spec.joinWith)) continue;

            Table child = working.get(childKey);
            Table parent = working.get(spec.joinWith);

            if (child.columnCount() <= 1) continue; // skip if only join key present
            if (parent.rowCount() == 0) continue;   // skip if parent has no rows

            Set<String> parentCols = new HashSet<>(parent.columnNames());
            List<String> toDrop = new ArrayList<>();
            for (String col : child.columnNames()) {
                if (!col.equals(spec.leftKey) && parentCols.contains(col)) {
                    toDrop.add(col);
                }
            }

            if (!toDrop.isEmpty()) {
                child = child.removeColumns(toDrop.toArray(new String[0]));
            }

            if (child.columnCount() <= 1) continue;

            Table joined = parent.joinOn(spec.rightKey).leftOuter(child, spec.leftKey);
            joinedResults.add(joined);
        }

        return mergeAll(joinedResults);
    }

    private static String findParentTableKey(String childKey, Table child, Map<String, Table> tables) {
        for (Map.Entry<String, Table> entry : tables.entrySet()) {
            String candidateKey = entry.getKey();
            if (candidateKey.equals(childKey)) continue; // avoid self-join

            Table t = entry.getValue();
            if (t.columnNames().contains("_row_id")) {
                return candidateKey;
            }
        }
        return null;
    }

    private static Table mergeAll(Collection<Table> tables) {
        Iterator<Table> it = tables.iterator();
        if (!it.hasNext()) return Table.create("empty");

        Table merged = it.next();
        while (it.hasNext()) {
            Table t = it.next();
            if (t.structure().equals(merged.structure())) {
                merged = merged.append(t);
            }
        }
        return merged;
    }
}
