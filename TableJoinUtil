import tech.tablesaw.api.*;

import java.util.*;

public class TableJoinUtil {

    public static Table joinAllByParentIdOnly(Map<String, Table> tables) {
        Map<String, Table> tableMap = new HashMap<>(tables);  // working copy
        Set<String> joinedTables = new HashSet<>();
        Table result = null;

        for (Map.Entry<String, Table> entry : tables.entrySet()) {
            String childName = entry.getKey();
            Table child = entry.getValue();

            if (!child.columnNames().contains("parent_id")) continue;

            // Find parent table by _row_id
            Table parent = findParentTable(child, tableMap);
            if (parent == null) continue;

            Set<String> parentCols = new HashSet<>(parent.columnNames());
            List<String> toDrop = new ArrayList<>();
            for (String col : child.columnNames()) {
                if (!col.equals("parent_id") && parentCols.contains(col)) {
                    toDrop.add(col);
                }
            }

            child = dropColumnsCompat(child, new HashSet<>(toDrop));

            Table joined = parent.joinOn("_row_id").inner(child, "parent_id");

            // Use this as the next parent if it's the deepest node
            result = joined;
            joinedTables.add(childName);
        }

        return result;
    }

    private static Table findParentTable(Table child, Map<String, Table> allTables) {
        for (Map.Entry<String, Table> entry : allTables.entrySet()) {
            Table t = entry.getValue();
            if (t.columnNames().contains("_row_id")) {
                return t;
            }
        }
        return null;
    }

    private static Table dropColumnsCompat(Table table, Set<String> columnsToDrop) {
        List<String> keep = new ArrayList<>();
        for (String col : table.columnNames()) {
            if (!columnsToDrop.contains(col)) {
                keep.add(col);
            }
        }
        return table.select(keep.toArray(new String[0]));
    }
}
